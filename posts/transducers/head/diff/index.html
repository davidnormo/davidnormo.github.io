<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>blog</title>
  <style>
  html { font-size: 12px; }
  body {
    font-family: Courier;
    font-size: 1em;
    line-height: 1.2em;
    padding: 20px;
    background: #fcfcfc;
    color: #333;
    max-width: 500px;
    margin: 0 auto;
    box-sizing: content-box;
    word-wrap: break-word;
  }
  h1 { font-size: 2em; line-height: 1em; font-weight: bold; }
  li { margin: 1em 0; }
  .title a {
    font-size: 2.5em;
    line-height: 1em;
    font-weight: bold;
    color: inherit;
  }
  .description {
    font-size: 0.9em;
    font-style: italic;
    line-height: 0.3em;
    margin-bottom: 20px;
  }
  pre {
    border: 1px solid #ccc;
    border-radius: 5px;
    padding: 15px;
    background: #f0f0f0;
    overflow: scroll;
    font-family: Courier;
    font-size: 1em;
  }
  pre code {
    padding: 0;
  }
  code {
    font-family: Courier;
    font-size: 1em;
    background: #f0f0f0;
    padding: 3px 5px;
  }
  blockquote {
    border-left: 5px solid #ddd;
    padding-left: 20px;
    margin: 40px 10px;
    font-style: italic;
  }
  @media (max-device-width: 812px) {
    body {
      max-width: 100vw;
      font-size: 1.4em;
      line-height: 1.5em;
    }
    h1 {
      /*font-size: 1.4em;*/
      /*line-height: 1em;*/
    }
    img {
      width: 100%
    }
  }
  </style>
  <link rel=stylesheet href=/assets/diff-styles.css />
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-51391788-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-51391788-2');
  </script>
</head>
<body class="f9 b9">
  <div class="title"><a href="/">Dave Normington</a></div>
  <p class="description">Lead Software Engineer at <a href="https://www.arcadiagroup.co.uk/">Arcadia</a></p>
  <pre><span class="bold">diff --git a/markdown/transducers.md b/markdown/transducers.md</span>
<span class="bold">new file mode 100644</span>
<span class="bold">index 0000000..3990572</span>
<span class="bold">--- /dev/null</span>
<span class="bold">+++ b/markdown/transducers.md</span>
<span class="f6">@@ -0,0 +1,195 @@</span>
<span class="f2">+Reuse logic, avoid duplication, maintain performance with transducers</span>
<span class="f2">+=====================================================================</span>
<span class="f2">+</span>
<span class="f2">+21 Oct 2016</span>
<span class="f2">+</span>
<span class="f2">+“What now?” may have been your first reaction. This post looks at how we can use advanced functional concepts to make your code more composable (and therefore reusable!). This is not a new concept but it’s not familiar to a lot of developers especially outside of the Clojure community, where they were invented.
+</span>
<span class="f2">+Transducers aren’t incomprehensible but they require a bit of patience and learning.</span>
<span class="f2">+</span>
<span class="f2">+TL;DR</span>
<span class="f2">+-----</span>
<span class="f2">+</span>
<span class="f2">+**Pros:** Composable transformation pipelines which are independent of their input and output sources and they perform really well. they perform really well.</span>
<span class="f2">+</span>
<span class="f2">+**Cons:** Transducers can be hard to get to grips with and they aren’t well known.</span>
<span class="f2">+</span>
<span class="f2">+What is a “transducer”?</span>
<span class="f2">+-----------------------</span>
<span class="f2">+</span>
<span class="f2">+A transducer is a function that accepts a reducing function and returns a reducing function. That’s it. Transducers are often wrapped with an initialising function that take extra arguments to augment the behaviour of the transducer like so:</span>
<span class="f2">+</span>
<span class="f2">+Fig. 1</span>
<span class="f2">+</span>
<span class="f2">+    const map = (fn) =&gt; { // `map` returns the transducer</span>
<span class="f2">+      return (rf) =&gt; { // the transducer, accepts a reducing function</span>
<span class="f2">+        return (acc, x) =&gt; { // and returns a reducing function</span>
<span class="f2">+          rf(acc, fn(x)); // ...that calls `fn` on every input `x`</span>
<span class="f2">+        };</span>
<span class="f2">+      };</span>
<span class="f2">+    };</span>
<span class="f2">+</span>
<span class="f2">+    // `map` doesn't know anything about the input or output,</span>
<span class="f2">+    // neither does the function it accepts,</span>
<span class="f2">+    // it only cares about the items it's reducing over</span>
<span class="f2">+    // (`xf` just stands for transducer)</span>
<span class="f2">+    const xf = map(x =&gt; x + 1)</span>
<span class="f2">+    // `sum` knows what the output is: a number</span>
<span class="f2">+    const sum = (total, x) =&gt; total + x;</span>
<span class="f2">+    // ...`transduce` is passed the input: an array</span>
<span class="f2">+    // `transduce` is like `reduce`</span>
<span class="f2">+    // Let's transform the array by adding 1 to all</span>
<span class="f2">+    // elements and reduce by summing the result</span>
<span class="f2">+    transduce(xf, sum, 0, [1,2,3,4,5]); // 20</span>
<span class="f2">+</span>
<span class="f2">+</span>
<span class="f2">+Transducers were introduced in Clojure but there are ports of it to Javascript! For a more comprehensive look at transducers check out the following resources:</span>
<span class="f2">+</span>
<span class="f2">+*   [Transducers.js: A Javascript Library for Transformation of Data](http://jlongster.com/Transducers.js--A-JavaScript-Library-for-Transformation-of-Data) [\[1\]](#ref8654)</span>
<span class="f2">+*   [Transducers](http://clojure.org/reference/transducers) [\[2\]](#ref245)</span>
<span class="f2">+*   [cognitect-labs/transducers-js](https://github.com/cognitect-labs/transducers-js) [\[3\]](#ref8752)</span>
<span class="f2">+</span>
<span class="f2">+What are the pros?</span>
<span class="f2">+------------------</span>
<span class="f2">+</span>
<span class="f2">+So, what’s good about them? Here is the breakdown of their offering:</span>
<span class="f2">+</span>
<span class="f2">+1.  [Composable transforms](#composable-transforms)</span>
<span class="f2">+2.  [Independent of their input and output](#independent-of-their-input-and-output)</span>
<span class="f2">+3.  [Performant](#performant)</span>
<span class="f2">+</span>
<span class="f2">+### 1\. Composable transforms</span>
<span class="f2">+</span>
<span class="f2">+Composition gives developers the ability to pick and choose, to build up transformations from other transducers and combinations of transducers. Let’s build on our earlier example but say this time we only wanted to sum the first 3 elements.</span>
<span class="f2">+</span>
<span class="f2">+Fig. 2</span>
<span class="f2">+</span>
<span class="f2">+    // `comp` stands for compose, it returns a function that</span>
<span class="f2">+    // chains the functions together.</span>
<span class="f2">+    // basically it does this: `comp(a,b,c)(x) =&gt; a(b(c(x)))`.</span>
<span class="f2">+    // In our case it returns a transducer!</span>
<span class="f2">+    const xf = comp (</span>
<span class="f2">+      pick(3), // `pick` returns a transducer that lets n elements pass</span>
<span class="f2">+      map(x =&gt; x + 1)</span>
<span class="f2">+    );</span>
<span class="f2">+    transduce(xf, sum, 0, [1,2,3,4,5]); // 9</span>
<span class="f2">+</span>
<span class="f2">+</span>
<span class="f2">+Pretty neat huh? Composition is less restrictive than method chaining as traditionally provided by lodash/underscore \[4\]. (Note: Lodash now supports functional composition via `flow`)</span>
<span class="f2">+</span>
<span class="f2">+It’s also a nicer abstraction than working with reducing functions directly. Although there is a complexity overhead, transducers are still actually quite readable.</span>
<span class="f2">+</span>
<span class="f2">+And because they are all just functions with the same signature you can get clever and compose pipelines!</span>
<span class="f2">+</span>
<span class="f2">+Fig. 3</span>
<span class="f2">+</span>
<span class="f2">+    const xf1 = comp( pick(...), map(...) );</span>
<span class="f2">+    const xf2 = comp( keep(...), filter(...) );</span>
<span class="f2">+    // comp chains functions right to left</span>
<span class="f2">+    // but transducers get evaluated left to right</span>
<span class="f2">+    // so below `xf1` is called before `xf2`</span>
<span class="f2">+    const xf3 = comp(</span>
<span class="f2">+      xf1,</span>
<span class="f2">+      xf2,</span>
<span class="f2">+      map(...)</span>
<span class="f2">+    );</span>
<span class="f2">+</span>
<span class="f2">+</span>
<span class="f2">+### 2\. Independent of their input and output</span>
<span class="f2">+</span>
<span class="f2">+A transducer operates only on the elements of the collection and knows nothing of the collection or of the result of the reduction. It doesn’t know if you are reducing from an array to a number, or from a stream or object. So you can reuse transducers on different data structures.</span>
<span class="f2">+</span>
<span class="f2">+Fig. 4</span>
<span class="f2">+</span>
<span class="f2">+    // `x` is a number but it doesn't know where it came from!</span>
<span class="f2">+    const xf = map(x =&gt; x + 1);</span>
<span class="f2">+</span>
<span class="f2">+    // an array sum into a number</span>
<span class="f2">+    transduce(xf, sum, 0, [1,2,3]);</span>
<span class="f2">+    // an array into another array!</span>
<span class="f2">+    into([], xf, [1,2,3]);</span>
<span class="f2">+    // immuatable list to a number!!</span>
<span class="f2">+    transduce(xf, sum, 0, List([1,2,3]));</span>
<span class="f2">+</span>
<span class="f2">+</span>
<span class="f2">+That means you can write a transducer once and use it in many contexts. This is because a transducer captures the essence of its step and avoids being tied to the data structure. For example, `map` is concerned with taking an input and returning a transformed input.</span>
<span class="f2">+</span>
<span class="f2">+### 3\. Performant</span>
<span class="f2">+</span>
<span class="f2">+Transducers are performant because they don’t build intermediate data structures. Let’s make that statement more concrete. Consider the following, non-transducer, alternative to [fig. 1](#fig1):</span>
<span class="f2">+</span>
<span class="f2">+Fig. 5</span>
<span class="f2">+</span>
<span class="f2">+    const arr = [1,2,3,4,5];</span>
<span class="f2">+</span>
<span class="f2">+    // our `pick` in terms of reduce</span>
<span class="f2">+    const tmp = arr.reduce((acc, x, i) =&gt; {</span>
<span class="f2">+      if (i &lt; 3) {</span>
<span class="f2">+        acc.push(x);</span>
<span class="f2">+      }</span>
<span class="f2">+</span>
<span class="f2">+      return acc;</span>
<span class="f2">+    }, []);</span>
<span class="f2">+</span>
<span class="f2">+    // our `map` in terms of reduce</span>
<span class="f2">+    const result = tmp.reduce((acc, x) =&gt; {</span>
<span class="f2">+      acc += x + 1;</span>
<span class="f2">+      return acc;</span>
<span class="f2">+    }, 0 );</span>
<span class="f2">+</span>
<span class="f2">+    result; // 9</span>
<span class="f2">+</span>
<span class="f2">+</span>
<span class="f2">+You’ll notice that `tmp` is just the result of our `pick` reduce. This is an “intermediate aggregate”. A collection that is just temporary before being passed to the next step in the pipeline. James Longster[\[1\]](#ref8654) says it nicely:</span>
<span class="f2">+</span>
<span class="f2">+&gt; ...transducers create no intermediate collections. If you want to apply several transformations, usually each one is performed in order, creating a new collection each time.</span>
<span class="f2">+&gt;</span>
<span class="f2">+&gt; Transducers, however, take one item off the collection at a time and fire it through the whole transformation pipeline. So it doesn't need any intermediate collections; each value runs through the pipeline separately.</span>
<span class="f2">+</span>
<span class="f2">+If we break the rules of big O notation for a minute, fig. 1 is roughly O(n) and fig. 5 is O(2n). Strictly speaking we drop constants and low-order terms in big O notation so they are both O(n) but benchmarks point out that one is more performant than the other[\[5\]](#ref8234).</span>
<span class="f2">+</span>
<span class="f2">+What are the cons?</span>
<span class="f2">+------------------</span>
<span class="f2">+</span>
<span class="f2">+To include transducers in a JS project, you need to weigh up both sides of the argument. So what are the issues to be aware of when using transducers?</span>
<span class="f2">+</span>
<span class="f2">+1.  **Complexity**</span>
<span class="f2">+    If you are new to the concept of transducers then you don’t need me to tell you that transducers are not a simple concept to grasp, especially if you aren’t familiar with functional programming concepts. You’ve got to consider the ability of your co-workers and the time it would take for them to get comfortable with transducers.
+</span>
<span class="f2">+2.  **Documentation and awareness**</span>
<span class="f2">+    Libraries such as lodash have much more extensive documentation, transducers - less so. There are many more questions/answers for using other solutions which aim to solve the same problems that transducers aim to solve. So if you get stuck with transducers, there is a greater risk that you will be stuck for longer.</span>
<span class="f2">+</span>
<span class="f2">+3.  **You might not get all the benefits of transducers**</span>
<span class="f2">+    Unless you have ONE of the following, I wouldn’t suggest to use transducers in a Javscript project:</span>
<span class="f2">+</span>
<span class="f2">+</span>
<span class="f2">+*   Your reducing function logic is becoming unwieldy and you’d benefit from a more composable approach OR</span>
<span class="f2">+*   You suffer from performance problems because of reasons stated in</span>
<span class="f2">+    [section 3](#performant) OR</span>
<span class="f2">+*   You use multiple data types such as custom iterable types, immutable.js types, streams, observables</span>
<span class="f2">+</span>
<span class="f2">+Conclusion</span>
<span class="f2">+----------</span>
<span class="f2">+</span>
<span class="f2">+Transducers are a really nice abstraction over reduce. If you work in a functional style codebase they may just make a nice fit. If not, it’s worth learning the concepts behind them. I’d recommend watching the talk[\[6\]](#ref2341) by Rich Hickey, the inventor, of transducers who gives both a great intro and walks through the internals of them also.
+</span>
<span class="f2">+References:</span>
<span class="f2">+-----------</span>
<span class="f2">+</span>
<span class="f2">+\[1\] &quot;Transducers.js: A Javascript Library for Transformation of Data&quot; by James Longster, 2014</span>
<span class="f2">+[http://jlongster.com/Transducers.js--A-JavaScript-Library-for-Transformation-of-Data](http://jlongster.com/Transducers.js--A-JavaScript-Library-for-Transformation-of-Data)</span>
<span class="f2">+</span>
<span class="f2">+\[2\] &quot;Transducers&quot;, Clojure docs</span>
<span class="f2">+[http://clojure.org/reference/transducers](http://clojure.org/reference/transducers)</span>
<span class="f2">+</span>
<span class="f2">+\[3\] cognitect-labs/transducers-js github repository</span>
<span class="f2">+[https://github.com/cognitect-labs/transducers-js](https://github.com/cognitect-labs/transducers-js)</span>
<span class="f2">+</span>
<span class="f2">+\[4\] &quot;Why using _.chain is a mistake&quot; by Izaak Schroeder, 2016</span>
<span class="f2">+[https://medium.com/making-internets/why-using-chain-is-a-mistake-9bc1f80d51ba#.ooakaw2vr](https://medium.com/making-internets/why-using-chain-is-a-mistake-9bc1f80d51ba#.ooakaw2vr)</span>
<span class="f2">+</span>
<span class="f2">+\[5\] &quot;Transducers.js Round 2 with Benchmarks&quot; by James Longster, 2014</span>
<span class="f2">+[http://jlongster.com/Transducers.js-Round-2-with-Benchmarks](http://jlongster.com/Transducers.js-Round-2-with-Benchmarks)</span>
<span class="f2">+</span>
<span class="f2">+\[6\] &quot;Transducers&quot; by Rich Hickey, 2014</span>
<span class="f2">+[https://youtu.be/6mTbuzafcII](https://youtu.be/6mTbuzafcII)</span>
\ No newline at end of file</pre>
  <!-- {{footer}} -->
</body>
</html>
